***************
*** 787,803 ****
  
    mIsOpenChanged = false;
    mCurrentMenu = nullptr; // make sure no current menu is set
    mHFlip = mVFlip = false;
  
    nsIView* view = GetView();
    nsIViewManager* viewManager = view->GetViewManager();
    viewManager->SetViewVisibility(view, nsViewVisibility_kHide);
-   viewManager->ResizeView(view, nsRect(0, 0, 0, 0));
  
    FireDOMEvent(NS_LITERAL_STRING("DOMMenuInactive"), mContent);
  
    // XXX, bug 137033, In Windows, if mouse is outside the window when the menupopup closes, no
    // mouse_enter/mouse_exit event will be fired to clear current hover state, we should clear it manually.
    // This code may not the best solution, but we can leave it here until we find the better approach.
    NS_ASSERTION(mContent->IsElement(), "How do we have a non-element?");
    nsEventStates state = mContent->AsElement()->State();
--- 787,802 ----
  
    mIsOpenChanged = false;
    mCurrentMenu = nullptr; // make sure no current menu is set
    mHFlip = mVFlip = false;
  
    nsIView* view = GetView();
    nsIViewManager* viewManager = view->GetViewManager();
    viewManager->SetViewVisibility(view, nsViewVisibility_kHide);
  
    FireDOMEvent(NS_LITERAL_STRING("DOMMenuInactive"), mContent);
  
    // XXX, bug 137033, In Windows, if mouse is outside the window when the menupopup closes, no
    // mouse_enter/mouse_exit event will be fired to clear current hover state, we should clear it manually.
    // This code may not the best solution, but we can leave it here until we find the better approach.
    NS_ASSERTION(mContent->IsElement(), "How do we have a non-element?");
    nsEventStates state = mContent->AsElement()->State();
