***************
*** 1399,1451 ****
      if (mFirstChunk.mNextChunk) {
          delete mFirstChunk.mNextChunk;
          mFirstChunk.mNextChunk = nullptr;
      }
  }
  
  /***************************************************************************/
  
- // If we have to transplant an object across compartments, we need to be
- // careful if the underlying object implements nsWrapperCache and is preserving
- // the wrapper.
- //
- // The class brackets a pair of Unpreserve/Preserve calls in the given scope.
- //
- // This class _must_ live on the stack, in part so that mPreservedWrapper is
- // visible to the stack scanner. The caller wants the wrapper to be preserved,
- // so we don't want it to get accidentally GCed.
- class AutoWrapperChanger NS_STACK_CLASS {
- public:
-     AutoWrapperChanger() : mCache(nullptr)
-                          , mCOMObj(nullptr)
-                          , mPreservedWrapper(nullptr)
-     {}
- 
-     void init(nsISupports* aCOMObj, nsWrapperCache* aWrapperCache) {
-         mCOMObj = aCOMObj;
-         mCache = aWrapperCache;
-         if (mCache->PreservingWrapper()) {
-             mPreservedWrapper = mCache->GetWrapper();
-             MOZ_ASSERT(mPreservedWrapper);
-             nsContentUtils::ReleaseWrapper(mCOMObj, mCache);
-         }
-     }
- 
-     ~AutoWrapperChanger() {
-         if (mPreservedWrapper)
-             nsContentUtils::PreserveWrapper(mCOMObj, mCache);
-     }
- 
- private:
-     nsWrapperCache* mCache;
-     nsISupports* mCOMObj;
-     JSObject* mPreservedWrapper;
- };
- 
  // Dynamically ensure that two objects don't end up with the same private.
  class AutoClonePrivateGuard NS_STACK_CLASS {
  public:
      AutoClonePrivateGuard(JSObject *aOld, JSObject *aNew)
          : mOldReflector(aOld), mNewReflector(aNew)
      {
          MOZ_ASSERT(JS_GetPrivate(aOld) == JS_GetPrivate(aNew));
      }
--- 1399,1414 ----
      if (mFirstChunk.mNextChunk) {
          delete mFirstChunk.mNextChunk;
          mFirstChunk.mNextChunk = nullptr;
      }
  }
  
  /***************************************************************************/
  
  // Dynamically ensure that two objects don't end up with the same private.
  class AutoClonePrivateGuard NS_STACK_CLASS {
  public:
      AutoClonePrivateGuard(JSObject *aOld, JSObject *aNew)
          : mOldReflector(aOld), mNewReflector(aNew)
      {
          MOZ_ASSERT(JS_GetPrivate(aOld) == JS_GetPrivate(aNew));
      }
***************
*** 1475,1500 ****
          XPCNativeInterface::GetISupports(ccx);
  
      if (!iface)
          return NS_ERROR_FAILURE;
  
      nsresult rv;
  
      nsRefPtr<XPCWrappedNative> wrapper;
-     AutoWrapperChanger wrapperChanger;
      JSObject *flat;
      nsWrapperCache* cache = nullptr;
      CallQueryInterface(aCOMObj, &cache);
      if (cache) {
- 
-         // There's a wrapper cache. Make sure we keep it sane no matter what
-         // happens.
-         wrapperChanger.init(aCOMObj, cache);
- 
          flat = cache->GetWrapper();
          if (flat && !IS_SLIM_WRAPPER_OBJECT(flat)) {
              wrapper = static_cast<XPCWrappedNative*>(xpc_GetJSPrivate(flat));
              NS_ASSERTION(wrapper->GetScope() == aOldScope,
                           "Incorrect scope passed");
          }
      } else {
          rv = XPCWrappedNative::GetUsedOnly(ccx, aCOMObj, aOldScope, iface,
--- 1438,1457 ----
          XPCNativeInterface::GetISupports(ccx);
  
      if (!iface)
          return NS_ERROR_FAILURE;
  
      nsresult rv;
  
      nsRefPtr<XPCWrappedNative> wrapper;
      JSObject *flat;
      nsWrapperCache* cache = nullptr;
      CallQueryInterface(aCOMObj, &cache);
      if (cache) {
          flat = cache->GetWrapper();
          if (flat && !IS_SLIM_WRAPPER_OBJECT(flat)) {
              wrapper = static_cast<XPCWrappedNative*>(xpc_GetJSPrivate(flat));
              NS_ASSERTION(wrapper->GetScope() == aOldScope,
                           "Incorrect scope passed");
          }
      } else {
          rv = XPCWrappedNative::GetUsedOnly(ccx, aCOMObj, aOldScope, iface,
***************
*** 1668,1685 ****
                  wrapper->SetWrapper(ww);
              } else {
                  flat = xpc::TransplantObject(ccx, flat, newobj);
                  if (!flat)
                      MOZ_CRASH();
              }
  
              wrapper->mFlatJSObject = flat;
-             if (cache)
                  cache->SetWrapper(flat);
              if (!JS_CopyPropertiesFrom(ccx, flat, propertyHolder))
                  MOZ_CRASH();
          } else {
              SetSlimWrapperProto(flat, newProto.get());
              if (!JS_SetPrototype(ccx, flat, newProto->GetJSProtoObject()))
                  MOZ_CRASH(); // this is bad, very bad
          }
  
--- 1625,1646 ----
                  wrapper->SetWrapper(ww);
              } else {
                  flat = xpc::TransplantObject(ccx, flat, newobj);
                  if (!flat)
                      MOZ_CRASH();
              }
  
              wrapper->mFlatJSObject = flat;
+             if (cache) {
+                 bool preserving = cache->PreservingWrapper();
+                 cache->SetPreservingWrapper(false);
                  cache->SetWrapper(flat);
+                 cache->SetPreservingWrapper(preserving);
+             }
              if (!JS_CopyPropertiesFrom(ccx, flat, propertyHolder))
                  MOZ_CRASH();
          } else {
              SetSlimWrapperProto(flat, newProto.get());
              if (!JS_SetPrototype(ccx, flat, newProto->GetJSProtoObject()))
                  MOZ_CRASH(); // this is bad, very bad
          }
  
